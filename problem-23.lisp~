(defun proper-divisors (num)
  (let ((flsq (floor (sqrt num)))
	(sq (sqrt num))
	(divisors (make-array 0 :fill-pointer t :adjustable t)))
    (loop for i from 2 to flsq do
	 (if (zerop (mod num i))
	     (progn
	       (vector-push-extend i divisors)
	       (if (not (equal sq i))
		   (vector-push-extend (/ num i) divisors)))))
    (vector-push-extend 1 divisors)
    (sort divisors #'>)))


(defun abundant-p (num)
  (let ((d (lambda (x) (reduce #'+ (proper-divisors x)))))
    (if (> (funcall d num) num)
        t
        nil)))

(defun deficient-p (num)
  (let ((d (lambda (x) (reduce #'+ (proper-divisors x)))))
    (if (< (funcall d num) num)
        t
        nil)))

(defun perfect-p (num)
  (and (not (abundant-p num)) (not (deficient-p num))))

(defun abundants ()
  (let ((abs (make-array 0 :fill-pointer t :adjustable t)))
    (loop for i from 1 to 28123 do
         (if (abundant-p i)
             (vector-push-extend i abs)))
    abs))

(defparameter *abundants* (abundants))

(defun abundant-sum-p (num)
  (let ((ret nil)
         (i 0)
         (j 0)
         (a 0)
         (b 0))
    (loop while (and (< i (length *abundants*))
                     (> num (setq a (aref *abundants* i)))) do
         (if (null ret)
             (progn
               (setq j i)
               (loop while (and (< j (length *abundants*))
                                (> (+ (- num a) 1)
                                   (setq b (aref *abundants* j)))) do
                    (if (equal num (+ a b))
                        (setf ret (vector a b)))
                    (incf j)))
             (return ret))
         (incf i))
    ret))


(defun sum-not-abundant ()
  (let ((sum 0))
    (loop for i from 1 to 28123 do
         (when (not (abundant-sum-p i))
           (print i)
           (setf sum (+ sum i))))
    sum))